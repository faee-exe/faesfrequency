<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>My Radio</title>
  <style>
    :root{--bg1:#0b0b0b;--bg2:#1b1b1b;--accent:#ff3b3b;--text:#eaeaea}
    *{box-sizing:border-box}
    body{
      margin:0; height:100vh; display:flex; align-items:center; justify-content:center;
      background: radial-gradient(circle at 50% 30%, var(--bg2), var(--bg1));
      color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }
    .wrap{display:flex; flex-direction:column; align-items:center; gap:22px}
    #playerContainer{position:relative; width:260px; height:260px; display:grid; place-items:center}
    #glowRing{
      position:absolute; width:240px; height:240px; border-radius:50%;
      background: conic-gradient(from 0deg, #ff7a7a, #ff3b3b, #ff7a7a);
      filter: blur(26px); opacity:0; transition:opacity .35s ease; animation:spin 7s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #playButton{
      width:190px; height:190px; border-radius:50%; border:none; cursor:pointer;
      background: linear-gradient(145deg, #2b2b2b, #171717);
      color:#fff; font-size:58px; line-height:1; display:grid; place-items:center;
      box-shadow: 0 14px 38px rgba(0,0,0,.55); transition: transform .2s ease, background .3s ease, opacity .2s;
      user-select:none;
    }
    #playButton.live{ background: linear-gradient(145deg, #ff5151, #ff2a2a); transform: scale(1.04); }
    #playButton:hover{ transform: scale(1.06); }
    #playButton.offline{ background: linear-gradient(145deg, #3b3b3b, #202020); opacity:.85; }
    #status{min-height:1.4em; font-size:18px; letter-spacing:.3px; text-shadow:0 0 10px rgba(0,0,0,.25)}
    #status.live{ color:#29ff88; }
    #status.offline{ color:#ff6a6a; }
    canvas{position:absolute; width:260px; height:260px; inset:0; pointer-events:none;}
    .sr{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0}
  </style>
</head>
<body>
  <main class="wrap">
    <h1 class="sr">Radio Player</h1>

    <div id="playerContainer">
      <div id="glowRing" aria-hidden="true"></div>
      <canvas id="visualizer" aria-hidden="true"></canvas>
      <button id="playButton" aria-label="Play / Pause">‚ñ∂Ô∏è</button>
    </div>

    <div id="status" role="status" aria-live="polite"></div>

    <!-- the real audio element -->
    <audio id="audioPlayer" preload="none" crossorigin="anonymous"></audio>
  </main>

  <script>
    // ====== CONFIG ======
    // use https if your site is https (recommended via nginx/cloudflare proxy)
    const streamURL = 'http://92.30.165.19:8000/stream';
    // ====================

    const audio = document.getElementById('audioPlayer');
    const playButton = document.getElementById('playButton');
    const statusDiv = document.getElementById('status');
    const glowRing = document.getElementById('glowRing');

    // state
    let isPlaying = false;
    let userPaused = false;           // true only when the user paused
    let clickLockUntil = 0;           // debounce to ignore accidental double-clicks

    function setLiveUI() {
      statusDiv.textContent = 'üéß Live Now';
      statusDiv.classList.add('live');  statusDiv.classList.remove('offline');
      playButton.classList.add('live'); playButton.classList.remove('offline');
      glowRing.style.opacity = '1';
    }
    function setIdleUI() {
      statusDiv.textContent = '';       // nothing while idle/paused
      statusDiv.classList.remove('live','offline');
      playButton.classList.remove('live','offline');
      glowRing.style.opacity = '0';
    }
    function setOfflineUI() {
      statusDiv.textContent = '‚ö†Ô∏è Offline';
      statusDiv.classList.add('offline'); statusDiv.classList.remove('live');
      playButton.classList.add('offline'); playButton.classList.remove('live');
      glowRing.style.opacity = '0';
    }

    // Debounced click handler
    playButton.addEventListener('click', () => {
      const now = performance.now();
      if (now < clickLockUntil) return;     // ignore rapid double-clicks
      clickLockUntil = now + 500;

      if (!isPlaying) {
        userPaused = false;
        // add a cache-buster to avoid stalled connections after stopping/starting
        audio.src = streamURL + (streamURL.includes('?') ? '&' : '?') + 't=' + Date.now();
        audio.play().then(() => {
          // playing event will handle UI
        }).catch(() => {
          // immediate failure -> show offline
          setOfflineUI();
        });
      } else {
        // user pressed pause
        userPaused = true;
        audio.pause();
      }
    });

    // --- Reliable status based on real audio events ---
    audio.addEventListener('playing', () => {
      isPlaying = true;
      playButton.textContent = '‚è∏Ô∏è';
      setLiveUI();
      startVisualizer();
    });

    audio.addEventListener('pause', () => {
      isPlaying = false;
      playButton.textContent = '‚ñ∂Ô∏è';
      // do NOT call Offline here; the user likely paused
      setIdleUI();
      stopVisualizer();
    });

    audio.addEventListener('ended', () => {
      isPlaying = false;
      playButton.textContent = '‚ñ∂Ô∏è';
      // stream ended by server; treat like idle (not an error)
      setIdleUI();
      stopVisualizer();
    });

    audio.addEventListener('waiting', () => {
      // buffering ‚Äì keep current UI, no offline flash
    });

    audio.addEventListener('stalled', () => {
      // network hiccup ‚Äì keep UI
    });

    audio.addEventListener('error', () => {
      isPlaying = false;
      playButton.textContent = '‚ñ∂Ô∏è';
      // only show Offline if this wasn't caused by a user pause
      if (!userPaused) setOfflineUI();
      stopVisualizer();
    });

    // ======== Visualizer ========
    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d', { alpha: true });
    let audioContext, analyser, source, dataArray, rafId = null;

    function startVisualizer() {
      if (audioContext) { draw(); return; }
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 256;
      const bufferLength = analyser.frequencyBinCount;
      dataArray = new Uint8Array(bufferLength);

      source = audioContext.createMediaElementSource(audio);
      source.connect(analyser);
      analyser.connect(audioContext.destination);
      draw();
    }

    function stopVisualizer() {
      if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function draw() {
      if (!isPlaying) return;
      rafId = requestAnimationFrame(draw);
      // ensure canvas internal size matches CSS size for crisp lines
      const { width, height } = canvas.getBoundingClientRect();
      if (canvas.width !== Math.floor(width * devicePixelRatio) ||
          canvas.height !== Math.floor(height * devicePixelRatio)) {
        canvas.width = Math.floor(width * devicePixelRatio);
        canvas.height = Math.floor(height * devicePixelRatio);
        ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      }

      analyser.getByteFrequencyData(dataArray);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const cx = canvas.width / devicePixelRatio / 2;
      const cy = canvas.height / devicePixelRatio / 2;
      const baseR = 78;

      for (let i = 0; i < dataArray.length; i++) {
        const a = (i / dataArray.length) * Math.PI * 2;
        const h = dataArray[i] / 3; // bar length
        const x0 = cx + Math.cos(a) * baseR;
        const y0 = cy + Math.sin(a) * baseR;
        const x1 = cx + Math.cos(a) * (baseR + h);
        const y1 = cy + Math.sin(a) * (baseR + h);
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
        ctx.lineWidth = 2;
        ctx.strokeStyle = `hsl(${(i / dataArray.length) * 360}, 100%, 60%)`;
        ctx.shadowBlur = 8;
        ctx.shadowColor = ctx.strokeStyle;
        ctx.stroke();
      }
    }

    // show idle UI on load
    setIdleUI();
  </script>
</body>
</html>
