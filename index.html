<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>My Radio</title>
  <style>
    :root{
      --bg1:#0b0b0b; --bg2:#151515; --ring:#ff3b3b; --ring2:#ff7676;
      --text:#e9e9e9; --ok:#29ff88; --warn:#ff6a6a;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; display:flex; align-items:center; justify-content:center; gap:24px;
      background: radial-gradient(90% 60% at 50% 30%, var(--bg2), var(--bg1));
      color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }
    .wrap{display:flex; flex-direction:column; align-items:center; gap:22px}

    /* --- Player layout --- */
    #playerContainer{
      position:relative; width:280px; height:280px; display:grid; place-items:center;
    }

    /* glow ring behind button */
    #glowRing{
      position:absolute; inset:0; margin:auto; width:260px; height:260px; border-radius:50%;
      background: conic-gradient(from 0deg, var(--ring2), var(--ring), var(--ring2));
      filter: blur(28px);
      opacity:0; transition:opacity .35s ease; animation: spin 7s linear infinite;
      z-index:1; pointer-events:none;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* visualizer canvas */
    #visualizer{
      position:absolute; inset:0; margin:auto; width:280px; height:280px;
      z-index:0; pointer-events:none;
    }

    /* the big button */
    #playButton{
      position:relative; z-index:3; width:200px; height:200px; border-radius:50%;
      border:none; background:linear-gradient(145deg,#2c2c2c,#161616);
      color:#fff; font-size:60px; display:grid; place-items:center;
      box-shadow: 0 18px 46px rgba(0,0,0,.55), inset 0 3px 10px rgba(255,255,255,.05);
      transition: transform .18s ease, background .25s ease, box-shadow .25s ease, opacity .2s;
      cursor:pointer; user-select:none; -webkit-tap-highlight-color: transparent;
      touch-action:manipulation;
    }
    #playButton:hover{ transform: scale(1.06); }
    #playButton:active{ transform: scale(0.98); }
    #playButton.live{ background:linear-gradient(145deg,#ff5151,#ff2a2a); }
    #playButton.offline{ background:linear-gradient(145deg,#3a3a3a,#202020); opacity:.9; }

    /* status text */
    #status{min-height:1.4em; font-size:18px; letter-spacing:.3px; text-shadow:0 0 10px rgba(0,0,0,.25)}
    #status.live{ color:var(--ok) }
    #status.offline{ color:var(--warn) }

    /* accessibility helper (screen-reader only) */
    .sr{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0}
  </style>
</head>
<body>
  <main class="wrap">
    <h1 class="sr">Radio Player</h1>

    <div id="playerContainer">
      <div id="glowRing" aria-hidden="true"></div>
      <canvas id="visualizer" aria-hidden="true"></canvas>
      <button id="playButton" aria-label="Play / Pause">‚ñ∂Ô∏è</button>
    </div>

    <div id="status" role="status" aria-live="polite"></div>

    <audio id="audioPlayer" preload="none" crossorigin="anonymous"></audio>
  </main>

  <script>
    // ====== CONFIG ======
    const streamURL = 'http://YOUR_HOST_OR_DOMAIN:8000/stream.mp3';
    // ====================

    const audio = document.getElementById('audioPlayer');
    const playButton = document.getElementById('playButton');
    const statusDiv = document.getElementById('status');
    const glowRing = document.getElementById('glowRing');

    // state
    let isPlaying = false;
    let userPaused = false;
    let clickLockUntil = 0; // debounce fast double-taps

    function setLiveUI() {
      statusDiv.textContent = 'üéß Live Now';
      statusDiv.classList.add('live');  statusDiv.classList.remove('offline');
      playButton.classList.add('live'); playButton.classList.remove('offline');
      glowRing.style.opacity = '1';
    }
    function setIdleUI() {
      statusDiv.textContent = '';
      statusDiv.classList.remove('live','offline');
      playButton.classList.remove('live','offline');
      glowRing.style.opacity = '0';
    }
    function setOfflineUI() {
      statusDiv.textContent = '‚ö†Ô∏è Offline';
      statusDiv.classList.add('offline'); statusDiv.classList.remove('live');
      playButton.classList.add('offline'); playButton.classList.remove('live');
      glowRing.style.opacity = '0';
    }

    // unified click/tap handler
    const playHandler = (e) => {
      if (e) { e.preventDefault(); e.stopPropagation(); }
      const now = performance.now();
      if (now < clickLockUntil) return; // ignore double-click spam
      clickLockUntil = now + 450;

      if (!isPlaying) {
        userPaused = false;
        // Cache-buster avoids ‚Äústuck‚Äù TCP sessions after previous stops
        audio.src = streamURL + (streamURL.includes('?') ? '&' : '?') + 't=' + Date.now();
        audio.play().catch(() => setOfflineUI());
      } else {
        userPaused = true;
        audio.pause();
      }
    };

    // pointer-friendly events (works on desktop + mobile)
    if (window.PointerEvent) {
      playButton.addEventListener('pointerup', playHandler);
    } else {
      playButton.addEventListener('touchend', playHandler, {passive:false});
      playButton.addEventListener('click', playHandler);
    }

    // --- reliable status driven by *real audio* events (no fetch/CORS issues) ---
    audio.addEventListener('playing', () => {
      isPlaying = true;
      playButton.textContent = '‚è∏Ô∏è';
      setLiveUI();
      startVisualizer();
    });

    audio.addEventListener('pause', () => {
      isPlaying = false;
      playButton.textContent = '‚ñ∂Ô∏è';
      setIdleUI();         // pause ‚â† offline
      stopVisualizer();
    });

    audio.addEventListener('ended', () => {
      isPlaying = false;
      playButton.textContent = '‚ñ∂Ô∏è';
      setIdleUI();         // stream ended gracefully
      stopVisualizer();
    });

    audio.addEventListener('waiting', () => {
      // buffering ‚Äî keep current UI, no flicker
    });
    audio.addEventListener('stalled', () => {
      // brief network hiccup ‚Äî keep UI
    });

    audio.addEventListener('error', () => {
      isPlaying = false;
      playButton.textContent = '‚ñ∂Ô∏è';
      if (!userPaused) setOfflineUI(); // only show Offline on real errors
      stopVisualizer();
    });

    // ======== Radial visualizer ========
    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d', { alpha:true });
    let audioContext, analyser, source, dataArray, rafId=null;

    function startVisualizer() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        source = audioContext.createMediaElementSource(audio);
        source.connect(analyser);
        analyser.connect(audioContext.destination);
      }
      draw();
    }

    function stopVisualizer() {
      if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    function draw() {
      if (!isPlaying) return;
      rafId = requestAnimationFrame(draw);

      // match canvas pixels to CSS size for crisp lines
      const rect = canvas.getBoundingClientRect();
      const px = Math.max(1, window.devicePixelRatio || 1);
      const w = Math.floor(rect.width * px), h = Math.floor(rect.height * px);
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w; canvas.height = h;
        ctx.setTransform(px,0,0,px,0,0);
      }

      analyser.getByteFrequencyData(dataArray);
      ctx.clearRect(0,0,canvas.width,canvas.height);

      const cx = rect.width/2, cy = rect.height/2, baseR = 86;
      for (let i=0;i<dataArray.length;i++){
        const angle = (i/dataArray.length)*Math.PI*2;
        const amp = dataArray[i]/3; // bar length
        const x0 = cx + Math.cos(angle)*baseR;
        const y0 = cy + Math.sin(angle)*baseR;
        const x1 = cx + Math.cos(angle)*(baseR+amp);
        const y1 = cy + Math.sin(angle)*(baseR+amp);

        ctx.beginPath();
        ctx.moveTo(x0,y0);
        ctx.lineTo(x1,y1);
        ctx.lineWidth = 2;
        ctx.strokeStyle = `hsl(${(i/dataArray.length)*360},100%,60%)`;
        ctx.shadowBlur = 8;
        ctx.shadowColor = ctx.strokeStyle;
        ctx.stroke();
      }
    }

    // initial idle UI
    setIdleUI();
  </script>
</body>
</html>
